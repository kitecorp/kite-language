package io.kite.Frontend.Parser;

import io.kite.Frontend.Parse.Literals.*;
import io.kite.Frontend.Parser.Expressions.*;
import io.kite.Frontend.Parser.Statements.*;
import io.kite.Frontend.Parser.generated.KiteParser;
import io.kite.Frontend.annotations.Annotatable;
import io.kite.TypeChecker.Types.ValueType;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.*;
import java.util.stream.Collectors;

import static io.kite.Frontend.Parser.generated.KiteParser.*;

/**
 * Converts ANTLR parse tree into Kite AST
 * <p>
 * This visitor walks the parse tree generated by KiteParser and builds
 * your existing AST classes (Program, ResourceStatement, etc.)
 */
public class KiteASTBuilder extends io.kite.Frontend.Parser.generated.KiteBaseVisitor<Object> {

    // ========================================================================
    // PROGRAM & STATEMENTS
    // ========================================================================

    @Override
    public Program visitProgram(ProgramContext ctx) {
        if (ctx.statementList() == null) {
            return new Program();
        }

        List<Statement> statements = ctx.statementList()
                .nonEmptyStatement()
                .stream()
                .map(stmtCtx -> (Statement) visit(stmtCtx))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        return new Program(statements);
    }

    @Override
    public Statement visitStatement(StatementContext ctx) {
        // Delegate to nonEmptyStatement or emptyStatement
        if (ctx.nonEmptyStatement() != null) {
            return (Statement) visit(ctx.nonEmptyStatement());
        } else if (ctx.emptyStatement() != null) {
            return new EmptyStatement();
        }
        return null;
    }

    @Override
    public Statement visitNonEmptyStatement(NonEmptyStatementContext ctx) {
        if (ctx.declaration() != null) {
            return (Statement) visit(ctx.declaration());
        } else if (ctx.ifStatement() != null) {
            return (Statement) visit(ctx.ifStatement());
        } else if (ctx.initStatement() != null) {
            return (Statement) visit(ctx.initStatement());
        } else if (ctx.returnStatement() != null) {
            return (Statement) visit(ctx.returnStatement());
        } else if (ctx.iterationStatement() != null) {
            return (Statement) visit(ctx.iterationStatement());
        } else if (ctx.blockExpression() != null) {
            // Block as a statement - wrap in ExpressionStatement
            return ExpressionStatement.expressionStatement(
                    (Expression) visit(ctx.blockExpression())
            );
        } else if (ctx.expressionStatement() != null) {
            return (Statement) visit(ctx.expressionStatement());
        }
        return null;
    }

    // ========================================================================
    // DECLARATIONS
    // ========================================================================

    @Override
    public Statement visitDeclaration(DeclarationContext ctx) {
        // Extract decorators first
        Set<AnnotationDeclaration> annotations = extractDecorators(ctx.decoratorList());

        // Delegate to specific declaration type
        Statement result;
        if (ctx.resourceDeclaration() != null) {
            result = visitResourceDeclaration(ctx.resourceDeclaration());
        } else if (ctx.componentDeclaration() != null) {
            result = visitComponentDeclaration(ctx.componentDeclaration());
        } else if (ctx.schemaDeclaration() != null) {
            result = visitSchemaDeclaration(ctx.schemaDeclaration());
        } else if (ctx.functionDeclaration() != null) {
            result = visitFunctionDeclaration(ctx.functionDeclaration());
        } else if (ctx.typeDeclaration() != null) {
            result = visitTypeDeclaration(ctx.typeDeclaration());
        } else if (ctx.inputDeclaration() != null) {
            result = visitInputDeclaration(ctx.inputDeclaration());
        } else if (ctx.outputDeclaration() != null) {
            result = visitOutputDeclaration(ctx.outputDeclaration());
        } else if (ctx.varDeclaration() != null) {
            result = visitVarDeclaration(ctx.varDeclaration());
        } else {
            return null;
        }

        // Attach annotations if the result supports them
        if (result instanceof Annotatable && !annotations.isEmpty()) {
            setAnnotations((Annotatable) result, annotations);
        }

        return result;
    }

    @Override
    public ResourceStatement visitResourceDeclaration(ResourceDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Expression name = (Expression) visit(ctx.resourceName());
        BlockExpression body = (BlockExpression) visit(ctx.blockExpression());

        // Annotations are handled in visitDeclaration
        return ResourceStatement.resource(Set.of(), type, name, body);
    }

    @Override
    public ComponentStatement visitComponentDeclaration(ComponentDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.componentType());
        Identifier name = ctx.identifier() != null ?
                (Identifier) visit(ctx.identifier()) : null;
        BlockExpression body = (BlockExpression) visit(ctx.blockExpression());

        return ComponentStatement.component(type, name, body, Set.of());
    }

    @Override
    public SchemaDeclaration visitSchemaDeclaration(SchemaDeclarationContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());

        List<SchemaProperty> properties = ctx.schemaProperty()
                .stream()
                .map(prop -> (SchemaProperty) visit(prop))
                .collect(Collectors.toList());

        return SchemaDeclaration.schema(name, properties, Set.of());
    }

    @Override
    public SchemaProperty visitSchemaProperty(SchemaPropertyContext ctx) {
        Set<AnnotationDeclaration> annotations = extractDecorators(ctx.decoratorList());
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Identifier name = (Identifier) visit(ctx.identifier());
        Expression init = ctx.propertyInitializer() != null ?
                (Expression) visit(ctx.propertyInitializer()) : null;

        return SchemaProperty.schemaProperty(type, name, init, annotations);
    }

    @Override
    public FunctionDeclaration visitFunctionDeclaration(FunctionDeclarationContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());
        List<ParameterIdentifier> params = ctx.parameterList() != null ?
                visitParameterList(ctx.parameterList()) : Collections.emptyList();
        TypeIdentifier returnType = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;
        Statement body = ExpressionStatement.expressionStatement(
                (Expression) visit(ctx.blockExpression()));

        return FunctionDeclaration.fun(name, params, returnType, body);
    }

    @Override
    public VarStatement visitVarDeclaration(VarDeclarationContext ctx) {
        List<VarDeclaration> declarations = ctx.varDeclarationList()
                .varDeclarator()
                .stream()
                .map(this::visitVarDeclarator)
                .collect(Collectors.toList());

        return VarStatement.varStatement(declarations);
    }

    public VarDeclaration visitVarDeclarator(VarDeclaratorContext ctx) {
        TypeIdentifier type = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;
        Identifier name = (Identifier) visit(ctx.identifier());
        Expression init = ctx.varInitializer() != null ?
                (Expression) visit(ctx.varInitializer()) : null;

        return VarDeclaration.of(name, type, init);
    }

    @Override
    public InputDeclaration visitInputDeclaration(InputDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Identifier name = (Identifier) visit(ctx.identifier());
        Expression defaultValue = ctx.expression() != null ?
                (Expression) visit(ctx.expression()) : null;

        return InputDeclaration.input(name, type, defaultValue, Set.of());
    }

    @Override
    public OutputDeclaration visitOutputDeclaration(OutputDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Identifier name = (Identifier) visit(ctx.identifier());
        Expression value = (Expression) visit(ctx.expression());

        return OutputDeclaration.output(name, type, value, Set.of());
    }

    @Override
    public UnionTypeStatement visitTypeDeclaration(TypeDeclarationContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());
        HashSet<Expression> types = new HashSet<>();

        for (var typeParam : ctx.typeParams().unionTypeParam()) {
            types.add((Expression) visit(typeParam));
        }

        return UnionTypeStatement.union(name, types);
    }

    // ========================================================================
    // CONTROL FLOW
    // ========================================================================

    @Override
    public IfStatement visitIfStatement(IfStatementContext ctx) {
        Expression test = (Expression) visit(ctx.expression());
        Statement consequent = (Statement) visit(ctx.statement());
        Statement alternate = ctx.elseStatement() != null ?
                (Statement) visit(ctx.elseStatement()) : null;

        return IfStatement.If(test, consequent, alternate);
    }

    @Override
    public Statement visitElseStatement(ElseStatementContext ctx) {
        return (Statement) visit(ctx.statement());
    }

    @Override
    public WhileStatement visitWhileStatement(WhileStatementContext ctx) {
        Expression test = (Expression) visit(ctx.expression());
        Statement body = (Statement) visit(ctx.statement());

        return WhileStatement.of(test, body);
    }

    @Override
    public ForStatement visitForStatement(ForStatementContext ctx) {
        Identifier item = (Identifier) visit(ctx.identifier(0));
        Identifier index = ctx.identifier().size() > 1 ?
                (Identifier) visit(ctx.identifier(1)) : null;

        Expression iterable;
        org.apache.commons.lang3.Range<Integer> range = null;

        if (ctx.rangeExpression() != null) {
            range = visitRangeExpression(ctx.rangeExpression());
            iterable = null;
        } else if (ctx.arrayExpression() != null) {
            iterable = (Expression) visit(ctx.arrayExpression());
        } else {
            iterable = (Identifier) visit(ctx.identifier(ctx.identifier().size() - 1));
        }

        Statement body = (Statement) visit(ctx.forBody());

        return ForStatement.builder()
                .item(item)
                .index(index)
                .range(range)
                .array(iterable)
                .body(body)
                .build();
    }

    public org.apache.commons.lang3.Range<Integer> visitRangeExpression(
            RangeExpressionContext ctx) {
        int start = Integer.parseInt(ctx.NUMBER(0).getText());
        int end = Integer.parseInt(ctx.NUMBER(1).getText());
        return org.apache.commons.lang3.Range.of(start, end);
    }

    @Override
    public ReturnStatement visitReturnStatement(ReturnStatementContext ctx) {
        Expression arg = ctx.expression() != null ?
                (Expression) visit(ctx.expression()) :
                TypeIdentifier.type(ValueType.Void);  // âœ… Default to void
        return ReturnStatement.funReturn(arg);
    }

    @Override
    public InitStatement visitInitStatement(InitStatementContext ctx) {
        List<ParameterIdentifier> params = ctx.parameterList() != null ?
                visitParameterList(ctx.parameterList()) : Collections.emptyList();
        Statement body = ExpressionStatement.expressionStatement(
                (Expression) visit(ctx.blockExpression()));

        return InitStatement.of(params, body);
    }

    // ========================================================================
    // EXPRESSIONS
    // ========================================================================

    @Override
    public Expression visitExpression(ExpressionContext ctx) {
        if (ctx.objectExpression() != null) {
            return (Expression) visit(ctx.objectExpression());
        } else if (ctx.arrayExpression() != null) {
            return (Expression) visit(ctx.arrayExpression());
        } else if (ctx.assignmentExpression() != null) {
            return (Expression) visit(ctx.assignmentExpression());
        }
        return null;
    }

    @Override
    public Expression visitAssignmentExpression(AssignmentExpressionContext ctx) {
        Expression left = (Expression) visit(ctx.orExpression());

        if (ctx.getChildCount() > 1) {
            // Has assignment operator
            String operator = ctx.getChild(1).getText(); // = or +=
            Expression right = (Expression) visit(ctx.assignmentExpression());
            return AssignmentExpression.assign(operator, left, right);
        }

        return left;
    }

    @Override
    public ExpressionStatement visitExpressionStatement(ExpressionStatementContext ctx) {
        Expression expr = (Expression) visit(ctx.expression());
        return ExpressionStatement.expressionStatement(expr);
    }

    @Override
    public Statement visitIterationStatement(KiteParser.IterationStatementContext ctx) {
        if (ctx.whileStatement() != null) {
            return visitWhileStatement(ctx.whileStatement());
        } else if (ctx.forStatement() != null) {
            return visitForStatement(ctx.forStatement());
        }
        return null;
    }

    @Override
    public Statement visitForBody(KiteParser.ForBodyContext ctx) {
        if (ctx.resourceDeclaration() != null) {
            return visitResourceDeclaration(ctx.resourceDeclaration());
        } else if (ctx.ifStatement() != null) {
            return visitIfStatement(ctx.ifStatement());
        } else if (ctx.expressionStatement() != null) {
            return visitExpressionStatement(ctx.expressionStatement());
        } else if (ctx.emptyStatement() != null) {
            return new EmptyStatement();
        }
        return null;
    }

    @Override
    public Expression visitPropertyInitializer(KiteParser.PropertyInitializerContext ctx) {
        return (Expression) visit(ctx.expression());
    }

    @Override
    public Expression visitVarInitializer(KiteParser.VarInitializerContext ctx) {
        return (Expression) visit(ctx.expression());
    }

    @Override
    public Expression visitLambdaBody(KiteParser.LambdaBodyContext ctx) {
        if (ctx.blockExpression() != null) {
            return visitBlockExpression(ctx.blockExpression());
        } else {
            return (Expression) visit(ctx.expression());
        }
    }

    @Override
    public Expression visitArrayItem(KiteParser.ArrayItemContext ctx) {
        return (Expression) visit(ctx.getChild(0)); // Delegates to appropriate type
    }

    @Override
    public Expression visitObjectKey(KiteParser.ObjectKeyContext ctx) {
        if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            value = value.substring(1, value.length() - 1); // Remove quotes
            return new StringLiteral(value);
        } else {
            return new StringLiteral(ctx.IDENTIFIER().getText());
        }
    }

    @Override
    public TypeIdentifier visitComponentType(KiteParser.ComponentTypeContext ctx) {
        return (TypeIdentifier) visit(ctx.typeIdentifier());
    }

    @Override
    public Expression visitResourceName(ResourceNameContext ctx) {
        if (ctx.identifier() != null) {
            return (Identifier) visit(ctx.identifier());
        } else if (ctx.callMemberExpression() != null) {
            return (Expression) visit(ctx.callMemberExpression());
        } else if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            value = value.substring(1, value.length() - 1);
            return new SymbolIdentifier(value);
        }
        return null;
    }

    @Override
    public Expression visitUnionTypeParam(KiteParser.UnionTypeParamContext ctx) {
        return (Expression) visit(ctx.getChild(0)); // Delegate to specific type
    }

    @Override
    public Expression visitOrExpression(OrExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.andExpression(0));

        for (int i = 1; i < ctx.andExpression().size(); i++) {
            Expression right = (Expression) visit(ctx.andExpression(i));
            result = LogicalExpression.of("||", result, right);
        }

        return result;
    }

    @Override
    public Expression visitAndExpression(AndExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.equalityExpression(0));

        for (int i = 1; i < ctx.equalityExpression().size(); i++) {
            Expression right = (Expression) visit(ctx.equalityExpression(i));
            result = LogicalExpression.of("&&", result, right);
        }

        return result;
    }

    @Override
    public Expression visitEqualityExpression(EqualityExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.relationalExpression(0));

        for (int i = 1; i < ctx.relationalExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // == or !=
            Expression right = (Expression) visit(ctx.relationalExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitRelationalExpression(RelationalExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.additiveExpression(0));

        for (int i = 1; i < ctx.additiveExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // <, >, <=, >=
            Expression right = (Expression) visit(ctx.additiveExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitAdditiveExpression(AdditiveExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.multiplicativeExpression(0));

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // + or -
            Expression right = (Expression) visit(ctx.multiplicativeExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitMultiplicativeExpression(MultiplicativeExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.unaryExpression(0));

        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // *, /, %
            Expression right = (Expression) visit(ctx.unaryExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitUnaryExpression(UnaryExpressionContext ctx) {
        if (ctx.getChildCount() > 1) {
            // Has unary operator
            String operator = ctx.getChild(0).getText(); // -, ++, --, !
            Expression operand = (Expression) visit(ctx.unaryExpression());
            return UnaryExpression.of(operator, operand);
        }

        return (Expression) visit(ctx.leftHandSideExpression());
    }

    @Override
    public Expression visitCallMemberExpression(CallMemberExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.primaryExpression());

        for (var accessCtx : ctx.callOrMemberAccess()) {
            // Check which alternative by looking at first child
            String firstChild = accessCtx.getChild(0).getText();

            if (firstChild.equals("(")) {
                // Function call: ( ... ) or ()
                List<Expression> args = accessCtx.argumentList() != null ?
                        accessCtx.argumentList().expression()
                                .stream()
                                .map(expr -> (Expression) visit(expr))
                                .collect(Collectors.toList())
                        : Collections.emptyList();
                result = CallExpression.call(result, args);

            } else if (firstChild.equals(".")) {
                // Property access: . identifier
                Expression property = (Identifier) visit(accessCtx.identifier());
                result = MemberExpression.member(false, result, property);

            } else if (firstChild.equals("[")) {
                // Index access: [ expression ]
                Expression index = (Expression) visit(accessCtx.expression());
                result = MemberExpression.member(true, result, index);
            }
        }

        return result;
    }

    @Override
    public Expression visitPrimaryExpression(PrimaryExpressionContext ctx) {
        if (ctx.literal() != null) {
            return (Expression) visit(ctx.literal());
        } else if (ctx.identifier() != null) {
            return (Identifier) visit(ctx.identifier());
        } else if (ctx.thisExpression() != null) {
            return ThisExpression.of();
        } else if (ctx.lambdaExpression() != null) {
            return (Expression) visit(ctx.lambdaExpression());
        } else if (ctx.expression() != null) {
            // Parenthesized expression
            return (Expression) visit(ctx.expression());
        }
        return null;
    }

    @Override
    public BlockExpression visitBlockExpression(BlockExpressionContext ctx) {
        if (ctx.statementList() == null) {
            return BlockExpression.block(Collections.emptyList());
        }

        List<Statement> statements = ctx.statementList()
                .nonEmptyStatement()
                .stream()
                .map(stmt -> (Statement) visit(stmt))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        return BlockExpression.block(statements);
    }

    @Override
    public Expression visitObjectExpression(ObjectExpressionContext ctx) {
        return (Expression) visit(ctx.objectDeclaration());
    }

    @Override
    public ObjectExpression visitObjectDeclaration(ObjectDeclarationContext ctx) {
        List<ObjectLiteral> properties = Collections.emptyList();

        if (ctx.objectPropertyList() != null) {
            properties = ctx.objectPropertyList()
                    .objectProperty()
                    .stream()
                    .map(this::visitObjectProperty)
                    .collect(Collectors.toList());
        }

        return ObjectExpression.object(properties);
    }

    public ObjectLiteral visitObjectProperty(ObjectPropertyContext ctx) {
        Expression key = (Expression) visit(ctx.objectKey());
        Expression value = ctx.objectInitializer() != null ?
                (Expression) visit(ctx.objectInitializer().expression()) : null;

        return ObjectLiteral.object(key, value);
    }

    @Override
    public ArrayExpression visitArrayExpression(ArrayExpressionContext ctx) {
        ArrayExpression array = new ArrayExpression();

        if (ctx.forStatement() != null) {
            ForStatement forStmt = (ForStatement) visit(ctx.forStatement());
            array.setForStatement(forStmt);
        } else if (ctx.arrayItems() != null) {
            for (var item : ctx.arrayItems().arrayItem()) {
                array.add((Expression) visit(item));
            }
        }

        return array;
    }

    @Override
    public LambdaExpression visitLambdaExpression(LambdaExpressionContext ctx) {
        List<ParameterIdentifier> params = ctx.parameterList() != null ?
                visitParameterList(ctx.parameterList()) : Collections.emptyList();
        TypeIdentifier returnType = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;
        Statement body = (Statement) visit(ctx.lambdaBody());

        return LambdaExpression.lambda(params, body, returnType);
    }

    // ========================================================================
    // TYPES & IDENTIFIERS
    // ========================================================================

    @Override
    public TypeIdentifier visitTypeIdentifier(TypeIdentifierContext ctx) {
        TypeIdentifier base;

        if (ctx.complexTypeIdentifier() != null) {
            base = (TypeIdentifier) visit(ctx.complexTypeIdentifier());
        } else if (ctx.OBJECT() != null) {
            base = TypeIdentifier.type("object");
        } else if (ctx.ANY() != null) {
            base = TypeIdentifier.type("any");
        } else {
            base = TypeIdentifier.type("unknown");
        }

        // Handle array brackets
        int arrayDimensions = ctx.getChildCount() - 1; // Subtract base type
        for (int i = 0; i < arrayDimensions / 2; i++) { // Each [] is 2 children
            base = ArrayTypeIdentifier.arrayType(base);
        }

        return base;
    }

    @Override
    public TypeIdentifier visitComplexTypeIdentifier(ComplexTypeIdentifierContext ctx) {
        String typeName = ctx.IDENTIFIER()
                .stream()
                .map(TerminalNode::getText)
                .collect(Collectors.joining("."));

        return TypeIdentifier.type(typeName);
    }

    @Override
    public Identifier visitIdentifier(IdentifierContext ctx) {
        if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            // Remove quotes
            value = value.substring(1, value.length() - 1);
            return new SymbolIdentifier(value);
        } else {
            return new SymbolIdentifier(ctx.IDENTIFIER().getText());
        }
    }

    public List<ParameterIdentifier> visitParameterList(ParameterListContext ctx) {
        return ctx.parameter()
                .stream()
                .map(this::visitParameter)
                .collect(Collectors.toList());
    }

    public ParameterIdentifier visitParameter(ParameterContext ctx) {
        TypeIdentifier type = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;
        Identifier name = (Identifier) visit(ctx.identifier());

        return ParameterIdentifier.param(name, type);
    }

    // ========================================================================
    // LITERALS
    // ========================================================================

    @Override
    public Literal visitLiteral(LiteralContext ctx) {
        if (ctx.NUMBER() != null) {
            return NumberLiteral.number(ctx.NUMBER().getText());
        } else if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            // Remove quotes
            value = value.substring(1, value.length() - 1);
            return StringLiteral.string(value);
        } else if (ctx.TRUE() != null) {
            return BooleanLiteral.bool(true);
        } else if (ctx.FALSE() != null) {
            return BooleanLiteral.bool(false);
        } else if (ctx.NULL() != null) {
            return NullLiteral.nullLiteral();
        }
        return null;
    }

    // ========================================================================
    // DECORATORS/ANNOTATIONS
    // ========================================================================

    private Set<AnnotationDeclaration> extractDecorators(DecoratorListContext ctx) {
        if (ctx == null) {
            return Collections.emptySet();
        }

        return ctx.decorator()
                .stream()
                .map(this::visitDecorator)
                .collect(Collectors.toSet());
    }

    public AnnotationDeclaration visitDecorator(DecoratorContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());

        if (ctx.decoratorArgs() == null) {
            return AnnotationDeclaration.annotation(name);
        }

        // Handle decorator arguments
        // This gets complex - you'll need to handle named args vs positional args
        // For now, return simple annotation
        return AnnotationDeclaration.annotation(name);
    }

    // ========================================================================
    // HELPERS
    // ========================================================================

    private void setAnnotations(Annotatable target, Set<AnnotationDeclaration> annotations) {
        // Set annotations and link them to the target
        for (var annotation : annotations) {
            annotation.setTarget(target);
        }

        if (target instanceof Annotatable annotatable) {
            annotatable.setAnnotations(annotations);
        }
        // Add other Annotatable types as needed
    }
}