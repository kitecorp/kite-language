package io.kite.Frontend.Parser;

import io.kite.Frontend.Parse.Literals.*;
import io.kite.Frontend.Parser.Expressions.*;
import io.kite.Frontend.Parser.Statements.*;
import io.kite.Frontend.Parser.generated.KiteParser;
import io.kite.Frontend.annotations.Annotatable;
import io.kite.TypeChecker.Types.FunType;
import io.kite.TypeChecker.Types.Type;
import io.kite.TypeChecker.Types.ValueType;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.*;
import java.util.stream.Collectors;

import static io.kite.Frontend.Parser.generated.KiteParser.*;

/**
 * Converts ANTLR parse tree into Kite AST
 * <p>
 * This visitor walks the parse tree generated by KiteParser and builds
 * your existing AST classes (Program, ResourceStatement, etc.)
 */
public class KiteASTBuilder extends io.kite.Frontend.Parser.generated.KiteBaseVisitor<Object> {

    // ========================================================================
    // PROGRAM & STATEMENTS
    // ========================================================================

    @Override
    public Program visitProgram(ProgramContext ctx) {
        if (ctx.statementList() == null) {
            return new Program();
        }

        List<Statement> statements = ctx.statementList()
                .nonEmptyStatement()
                .stream()
                .map(stmtCtx -> (Statement) visit(stmtCtx))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        return new Program(statements);
    }

    @Override
    public Statement visitStatement(StatementContext ctx) {
        // Delegate to nonEmptyStatement or emptyStatement
        if (ctx.nonEmptyStatement() != null) {
            return (Statement) visit(ctx.nonEmptyStatement());
        } else if (ctx.emptyStatement() != null) {
            return new EmptyStatement();
        }
        return null;
    }

    @Override
    public Statement visitNonEmptyStatement(NonEmptyStatementContext ctx) {
        if (ctx.declaration() != null) {
            return (Statement) visit(ctx.declaration());
        } else if (ctx.ifStatement() != null) {
            return (Statement) visit(ctx.ifStatement());
        } else if (ctx.initStatement() != null) {
            return (Statement) visit(ctx.initStatement());
        } else if (ctx.returnStatement() != null) {
            return (Statement) visit(ctx.returnStatement());
        } else if (ctx.iterationStatement() != null) {
            return (Statement) visit(ctx.iterationStatement());
        } else if (ctx.blockExpression() != null) {
            // Block as a statement - wrap in ExpressionStatement
            return ExpressionStatement.expressionStatement(
                    (Expression) visit(ctx.blockExpression())
            );
        } else if (ctx.expressionStatement() != null) {
            return (Statement) visit(ctx.expressionStatement());
        }
        return null;
    }

    // ========================================================================
    // DECLARATIONS
    // ========================================================================

    @Override
    public Statement visitDeclaration(DeclarationContext ctx) {
        Set<AnnotationDeclaration> annotations = extractDecorators(ctx.decoratorList());

        Statement result;
        if (ctx.resourceDeclaration() != null) {
            result = visitResourceDeclaration(ctx.resourceDeclaration());
        } else if (ctx.componentDeclaration() != null) {
            result = visitComponentDeclaration(ctx.componentDeclaration());
        } else if (ctx.schemaDeclaration() != null) {
            result = visitSchemaDeclaration(ctx.schemaDeclaration());
        } else if (ctx.functionDeclaration() != null) {
            result = visitFunctionDeclaration(ctx.functionDeclaration());
        } else if (ctx.typeDeclaration() != null) {
            result = visitTypeDeclaration(ctx.typeDeclaration());
        } else if (ctx.inputDeclaration() != null) {
            result = visitInputDeclaration(ctx.inputDeclaration());
        } else if (ctx.outputDeclaration() != null) {
            result = visitOutputDeclaration(ctx.outputDeclaration());
        } else if (ctx.varDeclaration() != null) {
            VarStatement varStmt = visitVarDeclaration(ctx.varDeclaration());

            // Attach annotations to each VarDeclaration
            if (!annotations.isEmpty()) {
                for (VarDeclaration varDecl : varStmt.getDeclarations()) {
                    setAnnotations(varDecl, annotations);
                }
            }
            return varStmt;
        } else {
            return null;
        }

        // Attach annotations if the result supports them
        if (result instanceof Annotatable && !annotations.isEmpty()) {
            setAnnotations((Annotatable) result, annotations);
        }

        return result;
    }

    @Override
    public ResourceStatement visitResourceDeclaration(ResourceDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Expression name = (Expression) visit(ctx.resourceName());
        BlockExpression body = (BlockExpression) visit(ctx.blockExpression());

        // Annotations are handled in visitDeclaration
        return ResourceStatement.resource(Set.of(), type, name, body);
    }

    @Override
    public ComponentStatement visitComponentDeclaration(ComponentDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.componentType());
        Identifier name = ctx.identifier() != null ?
                (Identifier) visit(ctx.identifier()) : null;
        BlockExpression body = (BlockExpression) visit(ctx.blockExpression());

        return ComponentStatement.component(type, name, body, Set.of());
    }

    @Override
    public SchemaDeclaration visitSchemaDeclaration(SchemaDeclarationContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());

        List<SchemaProperty> properties = ctx.schemaProperty()
                .stream()
                .map(prop -> (SchemaProperty) visit(prop))
                .collect(Collectors.toList());

        return SchemaDeclaration.schema(name, properties, Set.of());
    }

    @Override
    public SchemaProperty visitSchemaProperty(SchemaPropertyContext ctx) {
        Set<AnnotationDeclaration> annotations = extractDecorators(ctx.decoratorList());
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Identifier name = (Identifier) visit(ctx.identifier());
        Expression init = ctx.propertyInitializer() != null ?
                (Expression) visit(ctx.propertyInitializer()) : null;

        return SchemaProperty.schemaProperty(type, name, init, annotations);
    }

    @Override
    public FunctionDeclaration visitFunctionDeclaration(FunctionDeclarationContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());
        List<ParameterIdentifier> params = ctx.parameterList() != null ?
                visitParameterList(ctx.parameterList()) : Collections.emptyList();
        TypeIdentifier returnType = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;
        Statement body = ExpressionStatement.expressionStatement(
                (Expression) visit(ctx.blockExpression()));

        return FunctionDeclaration.fun(name, params, returnType, body);
    }

    @Override
    public VarStatement visitVarDeclaration(VarDeclarationContext ctx) {
        List<VarDeclaration> declarations = ctx.varDeclarationList()
                .varDeclarator()
                .stream()
                .map(this::visitVarDeclarator)
                .collect(Collectors.toList());

        return VarStatement.varStatement(declarations);
    }

    public VarDeclaration visitVarDeclarator(VarDeclaratorContext ctx) {
        TypeIdentifier type = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;
        Identifier name = (Identifier) visit(ctx.identifier());
        Expression init = ctx.varInitializer() != null ?
                (Expression) visit(ctx.varInitializer()) : null;

        return VarDeclaration.of(name, type, init);
    }

    @Override
    public InputDeclaration visitInputDeclaration(InputDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Identifier name = (Identifier) visit(ctx.identifier());
        Expression defaultValue = ctx.expression() != null ?
                (Expression) visit(ctx.expression()) : null;

        return InputDeclaration.input(name, type, defaultValue, Set.of());
    }

    @Override
    public OutputDeclaration visitOutputDeclaration(OutputDeclarationContext ctx) {
        TypeIdentifier type = (TypeIdentifier) visit(ctx.typeIdentifier());
        Identifier name = (Identifier) visit(ctx.identifier());

        if (ctx.expression() == null) {
            // Custom validation error
            String sourceText = ctx.getStart().getInputStream().getText(
                    new Interval(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex())
            );
            throw new ValidationException("Missing '=' after: " + sourceText);
        }

        Expression value = (Expression) visit(ctx.expression());
        return OutputDeclaration.output(name, type, value, Set.of());
    }

    @Override
    public UnionTypeStatement visitTypeDeclaration(TypeDeclarationContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());
        HashSet<Expression> types = new HashSet<>();

        for (var typeParam : ctx.typeParams().unionTypeParam()) {
            types.add((Expression) visit(typeParam));
        }

        return UnionTypeStatement.union(name, types);
    }

    // ========================================================================
    // CONTROL FLOW
    // ========================================================================

    @Override
    public IfStatement visitIfStatement(IfStatementContext ctx) {
        Expression test = (Expression) visit(ctx.expression());
        Statement consequent = ExpressionStatement.expressionStatement(
                (Expression) visit(ctx.blockExpression())
        );
        Statement alternate = ctx.elseStatement() != null ?
                (Statement) visit(ctx.elseStatement()) : null;

        return IfStatement.ifStatement(test, consequent, alternate);
    }

    @Override
    public Statement visitElseStatement(ElseStatementContext ctx) {
        return ExpressionStatement.expressionStatement(
                (Expression) visit(ctx.blockExpression())
        );
    }

    @Override
    public WhileStatement visitWhileStatement(WhileStatementContext ctx) {
        Expression test = (Expression) visit(ctx.expression());
        Statement body = ExpressionStatement.expressionStatement(
                (Expression) visit(ctx.blockExpression())
        );

        return WhileStatement.of(test, body);
    }

    @Override
    public ForStatement visitForStatement(ForStatementContext ctx) {
        Identifier item = (Identifier) visit(ctx.identifier(0));
        Identifier index = ctx.identifier().size() > 1 ?
                (Identifier) visit(ctx.identifier(1)) : null;

        Expression iterable;
        org.apache.commons.lang3.Range<Integer> range = null;

        if (ctx.rangeExpression() != null) {
            range = visitRangeExpression(ctx.rangeExpression());
            iterable = null;
        } else if (ctx.arrayExpression() != null) {
            iterable = (Expression) visit(ctx.arrayExpression());
        } else {
            iterable = (Identifier) visit(ctx.identifier(ctx.identifier().size() - 1));
        }

        Statement body = (Statement) visit(ctx.forBody());

        return ForStatement.builder()
                .item(item)
                .index(index)
                .range(range)
                .array(iterable)
                .body(body)
                .build();
    }

    public org.apache.commons.lang3.Range<Integer> visitRangeExpression(
            RangeExpressionContext ctx) {
        int start = Integer.parseInt(ctx.NUMBER(0).getText());
        int end = Integer.parseInt(ctx.NUMBER(1).getText());
        return org.apache.commons.lang3.Range.of(start, end);
    }

    @Override
    public ReturnStatement visitReturnStatement(ReturnStatementContext ctx) {
        Expression arg = ctx.expression() != null ?
                (Expression) visit(ctx.expression()) :
                TypeIdentifier.type(ValueType.Void);  // âœ… Default to void
        return ReturnStatement.funReturn(arg);
    }

    @Override
    public InitStatement visitInitStatement(InitStatementContext ctx) {
        List<ParameterIdentifier> params = ctx.parameterList() != null ?
                visitParameterList(ctx.parameterList()) : Collections.emptyList();
        Statement body = ExpressionStatement.expressionStatement(
                (Expression) visit(ctx.blockExpression()));

        return InitStatement.of(params, body);
    }

    // ========================================================================
    // EXPRESSIONS
    // ========================================================================

    @Override
    public Expression visitExpression(ExpressionContext ctx) {
        if (ctx.objectExpression() != null) {
            return (Expression) visit(ctx.objectExpression());
        } else if (ctx.arrayExpression() != null) {
            return (Expression) visit(ctx.arrayExpression());
        } else if (ctx.assignmentExpression() != null) {
            return (Expression) visit(ctx.assignmentExpression());
        }
        return null;
    }

    @Override
    public Expression visitAssignmentExpression(AssignmentExpressionContext ctx) {
        Expression left = (Expression) visit(ctx.orExpression());

        if (ctx.getChildCount() > 1) {
            // Has assignment operator
            String operator = ctx.getChild(1).getText(); // = or +=
            Expression right = (Expression) visit(ctx.expression());
            return AssignmentExpression.assign(operator, left, right);
        }

        return left;
    }

    @Override
    public ExpressionStatement visitExpressionStatement(ExpressionStatementContext ctx) {
        Expression expr = (Expression) visit(ctx.expression());
        return ExpressionStatement.expressionStatement(expr);
    }

    @Override
    public Statement visitIterationStatement(KiteParser.IterationStatementContext ctx) {
        if (ctx.whileStatement() != null) {
            return visitWhileStatement(ctx.whileStatement());
        } else if (ctx.forStatement() != null) {
            return visitForStatement(ctx.forStatement());
        }
        return null;
    }

    @Override
    public Statement visitForBody(ForBodyContext ctx) {
        if (ctx.blockExpression() != null) {
            return ExpressionStatement.expressionStatement(
                    (Expression) visit(ctx.blockExpression())
            );
        } else if (ctx.resourceDeclaration() != null) {
            return visitResourceDeclaration(ctx.resourceDeclaration());
        } else if (ctx.ifStatement() != null) {
            return visitIfStatement(ctx.ifStatement());
        } else if (ctx.expressionStatement() != null) {
            return visitExpressionStatement(ctx.expressionStatement());
        } else if (ctx.emptyStatement() != null) {
            return new EmptyStatement();
        }
        return null;
    }

    @Override
    public Expression visitPropertyInitializer(KiteParser.PropertyInitializerContext ctx) {
        return (Expression) visit(ctx.expression());
    }

    @Override
    public Expression visitVarInitializer(KiteParser.VarInitializerContext ctx) {
        return (Expression) visit(ctx.expression());
    }

    @Override
    public Expression visitLambdaBody(LambdaBodyContext ctx) {
        if (ctx.blockExpression() != null) {
            return visitBlockExpression(ctx.blockExpression());
        } else {
            return (Expression) visit(ctx.expression());
        }
    }

    @Override
    public Expression visitArrayItem(ArrayItemContext ctx) {
        if (ctx.typeKeyword() != null) {
            return (Expression) visit(ctx.typeKeyword());
        } else {
            return (Expression) visit(ctx.getChild(0));
        }
    }

    // Add this new visitor if not already present
    @Override
    public Expression visitTypeKeyword(TypeKeywordContext ctx) {
        if (ctx.OBJECT() != null) {
            return TypeIdentifier.type("object");
        } else if (ctx.ANY() != null) {
            return TypeIdentifier.type("any");
        }
        return null;
    }

    @Override
    public Expression visitObjectKey(KiteParser.ObjectKeyContext ctx) {
        if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            value = value.substring(1, value.length() - 1); // Remove quotes
            return new StringLiteral(value);
        } else {
            return new StringLiteral(ctx.IDENTIFIER().getText());
        }
    }

    @Override
    public TypeIdentifier visitComponentType(KiteParser.ComponentTypeContext ctx) {
        return (TypeIdentifier) visit(ctx.typeIdentifier());
    }

    @Override
    public Expression visitResourceName(ResourceNameContext ctx) {
        if (ctx.identifier() != null) {
            return (Identifier) visit(ctx.identifier());
        } else if (ctx.callMemberExpression() != null) {
            return (Expression) visit(ctx.callMemberExpression());
        } else if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            value = value.substring(1, value.length() - 1);
            return new SymbolIdentifier(value);
        }
        return null;
    }

    @Override
    public Expression visitUnionTypeParam(KiteParser.UnionTypeParamContext ctx) {
        return (Expression) visit(ctx.getChild(0)); // Delegate to specific type
    }

    @Override
    public Expression visitOrExpression(OrExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.andExpression(0));

        for (int i = 1; i < ctx.andExpression().size(); i++) {
            Expression right = (Expression) visit(ctx.andExpression(i));
            result = LogicalExpression.of("||", result, right);
        }

        return result;
    }

    @Override
    public Expression visitAndExpression(AndExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.equalityExpression(0));

        for (int i = 1; i < ctx.equalityExpression().size(); i++) {
            Expression right = (Expression) visit(ctx.equalityExpression(i));
            result = LogicalExpression.of("&&", result, right);
        }

        return result;
    }

    @Override
    public Expression visitEqualityExpression(EqualityExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.relationalExpression(0));

        for (int i = 1; i < ctx.relationalExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // == or !=
            Expression right = (Expression) visit(ctx.relationalExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitRelationalExpression(RelationalExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.additiveExpression(0));

        for (int i = 1; i < ctx.additiveExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // <, >, <=, >=
            Expression right = (Expression) visit(ctx.additiveExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitAdditiveExpression(AdditiveExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.multiplicativeExpression(0));

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // + or -
            Expression right = (Expression) visit(ctx.multiplicativeExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitMultiplicativeExpression(MultiplicativeExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.unaryExpression(0));

        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            String operator = ctx.getChild(i * 2 - 1).getText(); // *, /, %
            Expression right = (Expression) visit(ctx.unaryExpression(i));
            result = BinaryExpression.binary(result, right, operator);
        }

        return result;
    }

    @Override
    public Expression visitUnaryExpression(UnaryExpressionContext ctx) {
        if (ctx.getChildCount() > 1 &&
            (ctx.getChild(0).getText().equals("-") ||
             ctx.getChild(0).getText().equals("++") ||
             ctx.getChild(0).getText().equals("--") ||
             ctx.getChild(0).getText().equals("!"))) {
            // Prefix operator
            String operator = ctx.getChild(0).getText();
            Expression operand = (Expression) visit(ctx.unaryExpression());
            return UnaryExpression.of(operator, operand);
        }

        return (Expression) visit(ctx.postfixExpression());
    }

    @Override
    public Expression visitPostfixExpression(PostfixExpressionContext ctx) {
        Expression expr = (Expression) visit(ctx.leftHandSideExpression());

        if (ctx.getChildCount() > 1) {
            // Has postfix operator
            String operator = ctx.getChild(1).getText(); // ++ or --
            return UnaryExpression.of(operator, expr); // Mark as postfix
        }

        return expr;
    }

    @Override
    public Expression visitCallMemberExpression(CallMemberExpressionContext ctx) {
        Expression result = (Expression) visit(ctx.primaryExpression());

        for (var accessCtx : ctx.callOrMemberAccess()) {
            // Check which alternative by looking at first child
            String firstChild = accessCtx.getChild(0).getText();

            if (firstChild.equals("(")) {
                // Function call: ( ... ) or ()
                List<Expression> args = accessCtx.argumentList() != null ?
                        accessCtx.argumentList().expression()
                                .stream()
                                .map(expr -> (Expression) visit(expr))
                                .collect(Collectors.toList())
                        : Collections.emptyList();
                result = CallExpression.call(result, args);

            } else if (firstChild.equals(".")) {
                // Property access: . identifier
                Expression property = (Identifier) visit(accessCtx.identifier());
                result = MemberExpression.member(false, result, property);

            } else if (firstChild.equals("[")) {
                // Index access: [ expression ]
                Expression index = (Expression) visit(accessCtx.expression());
                result = MemberExpression.member(true, result, index);
            }
        }

        return result;
    }

    @Override
    public Expression visitPrimaryExpression(PrimaryExpressionContext ctx) {
        if (ctx.literal() != null) {
            return (Expression) visit(ctx.literal());
        } else if (ctx.identifier() != null) {
            return (Identifier) visit(ctx.identifier());
        } else if (ctx.thisExpression() != null) {
            return ThisExpression.of();
        } else if (ctx.lambdaExpression() != null) {
            return (Expression) visit(ctx.lambdaExpression());
        } else if (ctx.expression() != null) {
            // Parenthesized expression
            return (Expression) visit(ctx.expression());
        }
        return null;
    }

    @Override
    public BlockExpression visitBlockExpression(BlockExpressionContext ctx) {
        if (ctx.statementList() == null) {
            return BlockExpression.block(Collections.emptyList());
        }

        List<Statement> statements = ctx.statementList()
                .nonEmptyStatement()
                .stream()
                .map(stmt -> (Statement) visit(stmt))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        return BlockExpression.block(statements);
    }

    @Override
    public Expression visitObjectExpression(ObjectExpressionContext ctx) {
        return (Expression) visit(ctx.objectDeclaration());
    }

    @Override
    public ObjectExpression visitObjectDeclaration(ObjectDeclarationContext ctx) {
        List<ObjectLiteral> properties = Collections.emptyList();

        if (ctx.objectPropertyList() != null) {
            properties = ctx.objectPropertyList()
                    .objectProperty()
                    .stream()
                    .map(this::visitObjectProperty)
                    .collect(Collectors.toList());
        }

        return ObjectExpression.object(properties);
    }

    public ObjectLiteral visitObjectProperty(ObjectPropertyContext ctx) {
        Expression key = (Expression) visit(ctx.objectKey());
        Expression value = ctx.objectInitializer() != null ?
                (Expression) visit(ctx.objectInitializer().expression()) : null;

        return ObjectLiteral.object(key, value);
    }

    @Override
    public ArrayExpression visitArrayExpression(ArrayExpressionContext ctx) {
        ArrayExpression array = new ArrayExpression();

        if (ctx.FOR() != null) {
            // Determine if we have "item" or "item, index" form by checking the grammar
            // The grammar is: FOR identifier (',' identifier)? IN ...
            // So we check how many identifiers come BEFORE the iterable

            List<IdentifierContext> identifiers = ctx.identifier();

            Identifier item;
            Identifier index;

            // Check if there's a comma (meaning we have item, index form)
            // We can determine this by counting identifiers before IN
            // If arrayExpression or rangeExpression is present, the iterable is not an identifier
            // Otherwise, the last identifier is the iterable

            int loopVarCount;
            if (ctx.rangeExpression() != null || ctx.arrayExpression() != null) {
                // Iterable is not an identifier, so all identifiers are loop variables
                loopVarCount = identifiers.size();
            } else {
                // Last identifier is the iterable, rest are loop variables
                loopVarCount = identifiers.size() - 1;
            }

            if (loopVarCount == 2) {
                // for item, index in ...
                item = (Identifier) visit(identifiers.get(0));
                index = (Identifier) visit(identifiers.get(1));
            } else {
                // for item in ...
                item = (Identifier) visit(identifiers.get(0));
                index = null;
            }

            Expression iterable;
            org.apache.commons.lang3.Range<Integer> range = null;

            if (ctx.rangeExpression() != null) {
                range = visitRangeExpression(ctx.rangeExpression());
                iterable = null;
            } else if (ctx.arrayExpression() != null) {
                iterable = (Expression) visit(ctx.arrayExpression());
            } else {
                // Last identifier is the iterable
                iterable = (Identifier) visit(identifiers.get(identifiers.size() - 1));
            }

            Statement body;
            if (ctx.compactBody() != null) {
                body = (Statement) visit(ctx.compactBody());
            } else {
                body = (Statement) visit(ctx.forBody());
            }

            ForStatement forStmt = ForStatement.builder()
                    .item(item)
                    .index(index)
                    .range(range)
                    .array(iterable)
                    .body(body)
                    .build();
            array.setForStatement(forStmt);

        } else if (ctx.arrayItems() != null) {
            for (var arrayItem : ctx.arrayItems().arrayItem()) {
                array.add((Expression) visit(arrayItem));
            }
        }

        return array;
    }

    @Override
    public Statement visitCompactBody(CompactBodyContext ctx) {
        if (ctx.ifStatement() != null) {
            return visitIfStatement(ctx.ifStatement());
        } else {
            return ExpressionStatement.expressionStatement(
                    (Expression) visit(ctx.expression())
            );
        }
    }
    @Override
    public LambdaExpression visitLambdaExpression(LambdaExpressionContext ctx) {
        List<ParameterIdentifier> params = ctx.parameterList() != null ?
                visitParameterList(ctx.parameterList()) : Collections.emptyList();
        TypeIdentifier returnType = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;

        // Lambda body is an Expression, wrap it in ExpressionStatement
        Expression bodyExpr = (Expression) visit(ctx.lambdaBody());
        Statement body = ExpressionStatement.expressionStatement(bodyExpr);

        return LambdaExpression.lambda(params, body, returnType);
    }

    // ========================================================================
    // TYPES & IDENTIFIERS
    // ========================================================================

    @Override
    public TypeIdentifier visitTypeIdentifier(TypeIdentifierContext ctx) {
        TypeIdentifier base;

        // Handle function type: (number) -> string
        if (ctx.functionType() != null) {
            base = (TypeIdentifier) visit(ctx.functionType());
        } else if (ctx.complexTypeIdentifier() != null) {
            base = (TypeIdentifier) visit(ctx.complexTypeIdentifier());
        } else if (ctx.OBJECT() != null) {
            base = TypeIdentifier.type("object");
        } else if (ctx.ANY() != null) {
            base = TypeIdentifier.type("any");
        } else {
            base = TypeIdentifier.type("unknown");
        }

        // Handle array brackets
        int arrayDimensions = ctx.getChildCount() - 1;
        for (int i = 0; i < arrayDimensions / 2; i++) {
            base = ArrayTypeIdentifier.arrayType(base);
        }

        return base;
    }

    @Override
    public TypeIdentifier visitComplexTypeIdentifier(ComplexTypeIdentifierContext ctx) {
        String typeName = ctx.IDENTIFIER()
                .stream()
                .map(TerminalNode::getText)
                .collect(Collectors.joining("."));

        return TypeIdentifier.type(typeName);
    }

    @Override
    public Identifier visitIdentifier(IdentifierContext ctx) {
        if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            // Remove quotes
            value = value.substring(1, value.length() - 1);
            return new SymbolIdentifier(value);
        } else {
            return new SymbolIdentifier(ctx.IDENTIFIER().getText());
        }
    }

    public List<ParameterIdentifier> visitParameterList(ParameterListContext ctx) {
        return ctx.parameter()
                .stream()
                .map(this::visitParameter)
                .collect(Collectors.toList());
    }

    public ParameterIdentifier visitParameter(ParameterContext ctx) {
        TypeIdentifier type = ctx.typeIdentifier() != null ?
                (TypeIdentifier) visit(ctx.typeIdentifier()) : null;
        Identifier name = (Identifier) visit(ctx.identifier());

        return ParameterIdentifier.param(name, type);
    }

    // ========================================================================
    // LITERALS
    // ========================================================================

    @Override
    public Literal visitLiteral(LiteralContext ctx) {
        if (ctx.NUMBER() != null) {
            return NumberLiteral.number(ctx.NUMBER().getText());
        } else if (ctx.STRING() != null) {
            String value = ctx.STRING().getText();
            // Remove quotes
            value = value.substring(1, value.length() - 1);
            return StringLiteral.string(value);
        } else if (ctx.TRUE() != null) {
            return BooleanLiteral.bool(true);
        } else if (ctx.FALSE() != null) {
            return BooleanLiteral.bool(false);
        } else if (ctx.NULL() != null) {
            return NullLiteral.nullLiteral();
        }
        return null;
    }

    // ========================================================================
    // DECORATORS/ANNOTATIONS
    // ========================================================================

    private Set<AnnotationDeclaration> extractDecorators(DecoratorListContext ctx) {
        if (ctx == null) {
            return Collections.emptySet();
        }

        return ctx.decorator()
                .stream()
                .map(this::visitDecorator)
                .collect(Collectors.toSet());
    }

    @Override
    public TypeIdentifier visitFunctionType(FunctionTypeContext ctx) {
        // Parse parameter types
        List<Type> paramTypes = new ArrayList<>();
        if (ctx.functionTypeParams() != null) {
            for (var paramTypeCtx : ctx.functionTypeParams().typeIdentifier()) {
                TypeIdentifier paramTypeId = (TypeIdentifier) visit(paramTypeCtx);
                paramTypes.add(paramTypeId.getType());
            }
        }

        // Parse return type
        var returnTypeId = (TypeIdentifier) visit(ctx.typeIdentifier());
        var returnType = returnTypeId.getType();

        // Create FunType and wrap in TypeIdentifier
        var funType = FunType.fun(paramTypes, returnType);
        return TypeIdentifier.type(funType);
    }

    public AnnotationDeclaration visitDecorator(DecoratorContext ctx) {
        Identifier name = (Identifier) visit(ctx.identifier());

        if (ctx.decoratorArgs() == null) {
            return AnnotationDeclaration.annotation(name);
        }

        // Handle named arguments (convert to Map)
        if (!ctx.decoratorArgs().namedArg().isEmpty()) {
            Map<String, Expression> namedArgs = ctx.decoratorArgs().namedArg()
                    .stream()
                    .collect(Collectors.toMap(
                            namedArg -> ((Identifier) visit(namedArg.identifier())).string(),
                            namedArg -> (Expression) visit(namedArg.expression())
                    ));
            return AnnotationDeclaration.annotation(name, namedArgs);
        }

        // Handle positional arguments
        if (!ctx.decoratorArgs().decoratorArg().isEmpty()) {
            DecoratorArgContext firstArg = ctx.decoratorArgs().decoratorArg();

            // Object expression: @annotation({key: value})
            if (firstArg.objectExpression() != null) {
                ObjectExpression obj = (ObjectExpression) visit(firstArg.objectExpression());
                return AnnotationDeclaration.annotation(name, obj);
            }

            // Array expression: @annotation([1, 2, 3])
            if (firstArg.arrayExpression() != null) {
                ArrayExpression arr = (ArrayExpression) visit(firstArg.arrayExpression());
                return AnnotationDeclaration.annotation(name, arr);
            }

            // CallMemberExpression: @annotation(foo.bar())
            if (firstArg.callMemberExpression() != null) {
                Expression expr = (Expression) visit(firstArg.callMemberExpression());
                return AnnotationDeclaration.annotation(name, expr);
            }

            // Identifier: @annotation(myVar)
            if (firstArg.identifier() != null) {
                Identifier id = (Identifier) visit(firstArg.identifier());
                return AnnotationDeclaration.annotation(name, id);
            }

            // Literal: @annotation(2), @annotation("test"), @annotation(true)
            if (firstArg.literal() != null) {
                Expression lit = (Expression) visit(firstArg.literal());
                return AnnotationDeclaration.annotation(name, lit);
            }

            // Negative number: @annotation(-5)
            if (firstArg.NUMBER() != null) {
                NumberLiteral num = NumberLiteral.number("-" + firstArg.NUMBER().getText());
                return AnnotationDeclaration.annotation(name, num);
            }
        }

        // No arguments or unhandled case
        return AnnotationDeclaration.annotation(name);
    }

    // ========================================================================
    // HELPERS
    // ========================================================================

    private void setAnnotations(Annotatable target, Set<AnnotationDeclaration> annotations) {
        // Set annotations and link them to the target
        for (var annotation : annotations) {
            annotation.setTarget(target);
        }

        if (target instanceof Annotatable annotatable) {
            annotatable.setAnnotations(annotations);
        }
        // Add other Annotatable types as needed
    }
}